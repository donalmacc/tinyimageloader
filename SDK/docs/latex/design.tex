The goal of TinyImageLoader was to create a library that only loads images. It does color conversion, but nothing else. Therefor, the following design choices have been made.\hypertarget{design_interface}{}\section{Simple interface}\label{design_interface}
An interface that makes it as easy as possible to load an image.


\begin{DoxyItemize}
\item include \hyperlink{_tiny_image_loader_8h}{TinyImageLoader.h}
\item call \hyperlink{namespacetil_a84a20b430c5ae27956968ef6d7a6425b}{til::TIL\_\-Init}
\item call \hyperlink{namespacetil_a8d2e2ab942bb94b188587509ccb754de}{til::TIL\_\-Load}
\item extract data
\item call \hyperlink{namespacetil_a777e336727a478c4c4bdfd8c0e3603d7}{til::TIL\_\-ShutDown}
\end{DoxyItemize}

TinyImageLoader knows it is only a middleman. It exposes all its methods without fluff. There is no multiple inheritance. There is only the Image interface with its clear and descriptive method names.

You can keep the Image handles around after loading or you can copy the data to your own data structures. The choice is up to you.\hypertarget{design_extensibility}{}\section{Extensibility}\label{design_extensibility}
Despite the easy interface, TinyImageLoader can also be extended. You can write your own implementation of \hyperlink{classtil_1_1_file_stream}{til::FileStream} and attach it to TinyImageLoader. You can set the logging callback to output to a file by using \hyperlink{namespacetil_acf5fe389d33053c01da96da10ef88b0e}{TIL\_\-SetErrorFunc()}. You can even compile TinyImageLoader to only support a single format by setting a single define in the preprocessor definitions (\hyperlink{_t_i_l_settings_8h_ae0783dd47fcd9fe85766834d4fa8006d}{TIL\_\-FORMAT}).\hypertarget{design_speed}{}\section{Speed}\label{design_speed}
Speed is a priority, but no platform-\/specific hacks are used. If a loader doesn't work as expected on another platform then that is considered a bug. 